/*
 * 2023 (C) E. Bouchar√©
 */

#include "pin_mux.h"

#include "board.h"

#include "fsl_gpio.h"

#include "fsl_common.h"

#include "fsl_power.h"

//#ifdef FOR_TEST
#include "lcd.h"
 //#endif

/*******************************************************************************
 * Definitions
 ******************************************************************************/
//#define FOR_TEST

#ifdef FOR_TEST
#define LED_INIT()\
gpio_pin_config_t led_config = {
  \
  kGPIO_DigitalOutput,
  \
  0,
  \
};\
GPIO_PinInit(GPIO, BOARD_LED_RED_GPIO_PORT, BOARD_LED_RED_GPIO_PIN, & led_config);
#define LED_TOGGLE() GPIO_PortToggle(GPIO, BOARD_LED_RED_GPIO_PORT, 1 u << BOARD_LED_RED_GPIO_PIN);

#else

typedef enum {
  L_SOLID,
  L_DOTTED,
  L_DASHED,
  L_COMB,
  L_ARROW,
  L_BAR,
  L_FBAR,
  L_STEP,
  L_FSTEP,
  L_NONE
}
line_t;

typedef enum {
  M_CROSS,
  M_PLUS,
  M_DOT,
  M_STAR,
  M_CIRCLE,
  M_FCIRCLE,
  M_SQUARE,
  M_FSQUARE,
  M_DIAMOND,
  M_FDIAMOND,
  M_ARROW,
  M_TRIANGLE,
  M_FTRIANGLE,
  M_NONE
}
marker_t;

line_t ltype = L_SOLID;
marker_t mtype = M_NONE;
int msize = 6;

#endif
/*******************************************************************************
 * Mailbox and events
 ******************************************************************************/
#define EVT_MASK(0xFF << 24)

#define EVT_NONE 0
#define EVT_CORE_UP(1 U << 24)
#define EVT_RETVAL(2 U << 24)
#define EVT DRAWPOINT(3 U << 24)
#define EVT_DRAWLINE(4 U << 24)
#define EVT_DRAWRECT(5 U << 24)
#define EVT_DRAWRNDRECT(6 U << 24)
#define EVT_DRAWCIRCLE(7 U << 24)
#define EVT_DRAWELLISPSE(8 U << 24)
#define EVT_DRAWLINES(9 U << 24)
#define EVT_DRAWSEGMENTS(10 U << 24)
#define EVT_FILLRECT(11 U << 24)
#define EVT_CLIP(12 U << 24)
#define EVT_UNCLIP(13 U << 24)
#define EVT_DRAWPATH(14 U << 24)

#define EVT_FORECOLOR(15 U << 24)
#define EVT_BACKCOLOR(16 U << 24)
#define EVT_SETFONT(17 U << 24)

#define EVT_GETBUFFER(30 U << 24)
#define EVT_SETALIGN(31 U << 24)
#define EVT_DIRECTION(32 U << 24)
#define EVT_DRAWSTRING(33 U << 24)

/* mailbox communication between cores */
void mb_init(void) {
  //  Init already done by core0
  MAILBOX -> MBOXIRQ[0].IRQCLR = 0xFFFFFFFF;
  NVIC_SetPriority(MAILBOX_IRQn, 2);
  NVIC_EnableIRQ(MAILBOX_IRQn);
}

/* pop event from CPU0 */
uint32_t mb_pop_evt(void) {
  uint32_t evt = MAILBOX -> MBOXIRQ[0].IRQ;
  MAILBOX -> MBOXIRQ[0].IRQCLR = evt;
  return evt;
}

/* send event to CPU0, wait if there is already a pending event, unless force is set */
bool mb_push_evt(uint32_t evt, bool force) {
  if (MAILBOX -> MBOXIRQ[1].IRQ && !force) {
    return false;
  }
  MAILBOX -> MBOXIRQ[1].IRQSET = evt;
  return true;
}

/* event queue */
#define MAX_EVT_DATA 5
typedef struct _Event {
  uint32_t event;
  uint32_t data[MAX_EVT_DATA];
}
Event;

/* event queue handling */
#define MAX_EVTS 20

volatile Event evq[MAX_EVTS];
volatile int evq_rd = 0, evq_wr = 0;

bool next_event(Event * evt) {
  if (evq_rd == evq_wr) return false;

  * evt = evq[evq_rd];
  evq_rd = (evq_rd + 1) % MAX_EVTS;
  return true;
}

void MAILBOX_IRQHandler(void) {
  if (((evq_wr + 1) % MAX_EVTS) != evq_rd) {
    evq[evq_wr].event = mb_pop_evt();
    evq_wr = (evq_wr + 1) % MAX_EVTS;
  }
}

/*******************************************************************************
 * shared buffer
 ******************************************************************************/
extern SPoint __start_noinit_shmem[];
SPoint * shdata = __start_noinit_shmem;
volatile char * point;
void init_point() {
  point = (char * )(shdata + 2048);
}

/*******************************************************************************
 * main
 ******************************************************************************/
int main(void) {
  /* Init board hardware.*/
  init_point();
  #ifndef FOR_TEST
  lcd_init();
  lcd_switch_to(LCD_DPY);
  #endif
  /* Initialize mailbox, send EVT_CORE_UP to notify core 0 that core 1 is up
   * and ready to work.
   */
  mb_init();
  mb_push_evt(EVT_CORE_UP, true);

  #ifndef FOR_TEST
  Event ev;
  uint16_t x0, x1, y0, y1, w, h, c;
  uint32_t Z0;
  int n;
  DC dc;
  Font font;

  lcd_get_default_DC( & dc);
  for (;;) {
    while (!next_event( & ev)) {}
    switch (ev.event & EVT_MASK) {
    case EVT_FORECOLOR:
      dc.fcolor = (Color)(ev.event & 0x0000FFFF);
      break;

    case EVT_DRAWLINES:
      n = ev.event & 0x000007FF;
      x0 = shdata[0].x;
      y0 = shdata[0].y;
      for (int i = 1; i < n; i++) {
        x1 = shdata[i].x;
        y1 = shdata[i].y;
        lcd_line(x0, y0, x1, y1, dc.fcolor);
        x0 = x1;
        y0 = y1;
      }
      mb_push_evt(EVT_RETVAL, true);
      break;

    case EVT_DRAWSEGMENTS:
      n = ev.event & 0x000007FF;
      n = ev.event & 0x000007FF;
      x0 = (uint16_t) point[0] | (uint16_t) point[1] << 8;
      lcd_draw_segments(shdata, n & 0x7FF, (Color) x0);
      mb_push_evt(EVT_RETVAL, true);
      break;

    case EVT_DRAWPATH:
      n = ev.event & 0x00FFFFFF;
      //lcd_draw_path2d(&shdata,n,n);
      mb_push_evt(EVT_RETVAL, true);
      break;

    case EVT_FILLRECT:

      x0 = (uint16_t) point[0] | ((uint16_t) point[1] << 8);
      y0 = (uint16_t) point[2] | ((uint16_t) point[3] << 8);
      w = (uint16_t) point[4] | ((uint16_t) point[5] << 8);
      h = (uint16_t) point[6] | ((uint16_t) point[7] << 8);
      uint16_t color = (uint16_t) point[8] | ((uint16_t) point[9] << 8);
      lcd_fill_rect(x0, y0, w, h, color);
      mb_push_evt(EVT_RETVAL, true);
      break;

    case EVT_DRAWRECT:
      x0 = (uint16_t) point[0] | ((uint16_t) point[1] << 8);
      y0 = (uint16_t) point[2] | ((uint16_t) point[3] << 8);
      w = (uint16_t) point[4] | ((uint16_t) point[5] << 8);
      h = (uint16_t) point[6] | ((uint16_t) point[7] << 8);
      c = (uint16_t) point[8] | ((uint16_t) point[9] << 8);
      lcd_draw_rect(x0, y0, w, h, c);
      mb_push_evt(EVT_RETVAL, true);
      break;
    case EVT_CLIP:
      int x1 = (int) point[0] | ((int) point[1] << 8);
      int y1 = (int) point[2] | ((int) point[3] << 8);
      int x2 = (int) point[4] | ((int) point[5] << 8);
      int y2 = (int) point[6] | ((int) point[7] << 8);
      lcd_clip(x1, y1, x2, y2);
      mb_push_evt(EVT_RETVAL, true);
      break;
    case EVT_UNCLIP:
      lcd_unclip();
      mb_push_evt(EVT_RETVAL, true);
      break;
    case EVT_SETFONT:
      font.data = (uint16_t) point[0] | ((uint16_t) point[1] << 8);
      font.height = (uint16_t) point[2] | ((uint16_t) point[3] << 8);
      font.width = (uint16_t) point[4] | ((uint16_t) point[5] << 8);
      lcd_set_font( & dc, & font);
      mb_push_evt(EVT_RETVAL, true);
      break;
    case EVT_SETALIGN:
      Z0 = (uint32_t) point[0] | ((uint32_t) point[1] << 8) | ((uint32_t) point[2] << 16) | ((uint32_t) point[3] << 24);
      lcd_set_alignment( & dc, Z0);
      mb_push_evt(EVT_RETVAL, true);
      break;
    case EVT_DIRECTION:
      Z0 = (uint32_t) point[0] | ((uint32_t) point[1] << 8) | ((uint32_t) point[2] << 16) | ((uint32_t) point[3] << 24);
      lcd_set_direction( & dc, Z0);
      mb_push_evt(EVT_RETVAL, true);
      break;
    case EVT_DRAWSTRING:
      buffer_number = (ev.event & 0x00FF0000) >> 16;
      x0 = ((uint16_t) point[1] << 8) | (uint16_t) point[0];
      y0 = ((uint16_t) point[3] << 8) | (uint16_t) point[2];
      lcd_draw_string( & dc, x0, y0, & point[4]);
      buffer[buffer_number].is_free = true;
      mb_push_evt(EVT_RETVAL, true);
      break;
    default:
      break;
    }
  }
  #else
  /* enable clock for GPIO */
  CLOCK_EnableClock(kCLOCK_Gpio0);
  CLOCK_EnableClock(kCLOCK_Gpio1);
  BOARD_InitBootPins();
  /* Make a noticable delay after the reset */
  /* Use startup parameter from the master core... */
  for (int i = 0; i < 2; i++) {
    SDK_DelayAtLeastUs(1000000 U, 150000000 L);
  }

  /* Configure LED */
  LED_INIT();

  for (;;) {
    SDK_DelayAtLeastUs(500000 U, 150000000 L);
    LED_TOGGLE();
  }
  #endif
}
